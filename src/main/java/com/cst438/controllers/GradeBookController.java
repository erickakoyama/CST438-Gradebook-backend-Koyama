package com.cst438.controllers;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import com.cst438.domain.Assignment;
import com.cst438.domain.AssignmentListDTO;
import com.cst438.domain.AssignmentGrade;
import com.cst438.domain.AssignmentGradeRepository;
import com.cst438.domain.AssignmentRepository;
import com.cst438.domain.Course;
import com.cst438.domain.CourseDTOG;
import com.cst438.domain.CourseRepository;
import com.cst438.domain.Enrollment;
import com.cst438.domain.GradebookDTO;
import com.cst438.services.RegistrationService;


@RestController
@CrossOrigin(origins = "https://cst438grade-fe-koyama.herokuapp.com/")
public class GradeBookController {
	
	@Autowired
	AssignmentRepository assignmentRepository;
	
	@Autowired
	AssignmentGradeRepository assignmentGradeRepository;
	
	@Autowired
	CourseRepository courseRepository;
	
	@Autowired
	RegistrationService registrationService;
	
	// get assignments for an instructor that need grading
	@GetMapping("/gradebook")
	public AssignmentListDTO getAssignmentsNeedGrading() {
		
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email) 
		
		List<Assignment> assignments = assignmentRepository.findNeedGradingByEmail(email);
		AssignmentListDTO result = new AssignmentListDTO();
		for (Assignment a: assignments) {
			result.assignments.add(new AssignmentListDTO.AssignmentDTO(a.getId(), a.getCourse().getCourse_id(), a.getName(), a.getDueDate().toString() , a.getCourse().getTitle()));
		}
		System.out.println("=====> Number of assignments: " + result.assignments.size());
		return result;
	}
	
	@GetMapping("/gradebook/{id}")
	public GradebookDTO getGradebook(@PathVariable("id") int assignmentId  ) {
		
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email) 
		Assignment assignment = checkAssignment(assignmentId, email);
		
		// get the enrollment for the course
		//  for each student, get the current grade for assignment, 
		//   if the student does not have a current grade, create an empty grade
		GradebookDTO gradebook = new GradebookDTO();
		gradebook.assignmentId= assignmentId;
		gradebook.assignmentName = assignment.getName();
		for (Enrollment e : assignment.getCourse().getEnrollments()) {
			GradebookDTO.Grade grade = new GradebookDTO.Grade();
			grade.name = e.getStudentName();
			grade.email = e.getStudentEmail();
			// does student have a grade for this assignment
			AssignmentGrade ag = assignmentGradeRepository.findByAssignmentIdAndStudentEmail(assignmentId,  grade.email);
			if (ag != null) {
				grade.grade = ag.getScore();
				grade.assignmentGradeId = ag.getId();
			} else {
				grade.grade = "";
				AssignmentGrade agNew = new AssignmentGrade(assignment, e);
				agNew = assignmentGradeRepository.save(agNew);
				grade.assignmentGradeId = agNew.getId();  // key value generated by database on save.
			}
			gradebook.grades.add(grade);
		}
		return gradebook;
	}
	
	@PostMapping("/course/{course_id}/finalgrades")
	@Transactional
	public void calcFinalGrades(@PathVariable int course_id) {
		System.out.println("Gradebook - calcFinalGrades for course " + course_id);
		
		// check that this request is from the course instructor 
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email) 
		
		Course c = courseRepository.findByCourse_id(course_id);
		if (!c.getInstructor().equals(email)) {
			throw new ResponseStatusException( HttpStatus.UNAUTHORIZED, "Not Authorized. " );
		}
		
		CourseDTOG cdto = new CourseDTOG();
		cdto.course_id = course_id;
		cdto.grades = new ArrayList<>();
		for (Enrollment e: c.getEnrollments()) {
			double total=0.0;
			int count = 0;
			for (AssignmentGrade ag : e.getAssignmentGrades()) {
				count++;
				total = total + Double.parseDouble(ag.getScore());
			}
			double average = total/count;
			CourseDTOG.GradeDTO gdto = new CourseDTOG.GradeDTO();
			gdto.grade=letterGrade(average);
			gdto.student_email=e.getStudentEmail();
			gdto.student_name=e.getStudentName();
			cdto.grades.add(gdto);
			System.out.println("Course="+course_id+" Student="+e.getStudentEmail()+" grade="+gdto.grade);
		}
		
		registrationService.sendFinalGrades(course_id, cdto);
	}
	
	private String letterGrade(double grade) {
		if (grade >= 90) return "A";
		if (grade >= 80) return "B";
		if (grade >= 70) return "C";
		if (grade >= 60) return "D";
		return "F";
	}
	
	@PutMapping("/gradebook/{id}")
	@Transactional
	public void updateGradebook (@RequestBody GradebookDTO gradebook, @PathVariable("id") int assignmentId ) {
		
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email) 
		checkAssignment(assignmentId, email);  // check that user name matches instructor email of the course.
		
		// for each grade in gradebook, update the assignment grade in database 
		
		for (GradebookDTO.Grade g : gradebook.grades) {
			AssignmentGrade ag = assignmentGradeRepository.findById(g.assignmentGradeId);
			if (ag == null) {
				throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Invalid grade primary key. "+g.assignmentGradeId);
			}
			ag.setScore(g.grade);
			assignmentGradeRepository.save(ag);
		}
		
	}
	
	// @author Ericka Koyama
	@GetMapping("/assignment/{id}")
	@Transactional
	public AssignmentListDTO.AssignmentDTO getAssignment (@PathVariable("id") int assignmentId) {
		
		// Create assignment entity
		Optional<Assignment> optA = assignmentRepository.findById(assignmentId);
		if (optA.isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Invalid assignment primary key. " + assignmentId);
		}
		Assignment a = optA.get();
		
		AssignmentListDTO.AssignmentDTO assignmentDTORes = new AssignmentListDTO.AssignmentDTO();
		assignmentDTORes.assignmentId = a.getId();
		assignmentDTORes.assignmentName = a.getName();
		assignmentDTORes.dueDate = a.getDueDate().toString();
		assignmentDTORes.courseTitle = a.getCourse().getTitle();
		assignmentDTORes.courseId = a.getCourse().getCourse_id();
		
		return assignmentDTORes;
	}

	// @author Ericka Koyama
	@PostMapping("/assignment")
	@Transactional
	public AssignmentListDTO.AssignmentDTO createAssignment (@RequestBody AssignmentListDTO.AssignmentDTO assignmentDTO) {
		// check that this request is from the course instructor 
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email)
		checkNewAssignmentFields(assignmentDTO);  // check that assignment has all of the required fields
		// check that instructor matches course
		checkInstructorCoursePerms(assignmentDTO.courseId, email);
		
		// Create assignment entity
		Assignment a = new Assignment();
		
		// Handle date field
		java.util.Date utilDate;
		try {
			utilDate = new SimpleDateFormat("yyyy-MM-dd").parse(assignmentDTO.dueDate);
		} catch (ParseException e) {
			e.printStackTrace();
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Assignment due date not formatted correctly");
		}
		
		java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());
		
		
		// Handle course field
		Course course = courseRepository.findByCourse_id(assignmentDTO.courseId);
		if (course == null) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Invalid course primary key. " + assignmentDTO.courseId);
		}
		a.setCourse(course);
		
		// Handle other fields
		a.setDueDate(sqlDate);
		a.setName(assignmentDTO.assignmentName);
		
		assignmentRepository.save(a);
		
		AssignmentListDTO.AssignmentDTO assignmentDTORes = new AssignmentListDTO.AssignmentDTO();
		assignmentDTORes.assignmentId = a.getId();
		assignmentDTORes.assignmentName = a.getName();
		assignmentDTORes.dueDate = a.getDueDate().toString();
		assignmentDTORes.courseTitle = a.getCourse().getTitle();
		assignmentDTORes.courseId = a.getCourse().getCourse_id();
		
		return assignmentDTORes;
	}
	
	// @author Ericka Koyama
	@PatchMapping("/assignment/{id}")
	@Transactional
	public AssignmentListDTO.AssignmentDTO updateAssignment (
			@RequestBody AssignmentListDTO.AssignmentDTO assignmentDTO,
			@PathVariable("id") int assignmentId
	) {
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email)
		// Create assignment entity
		Optional<Assignment> optA = assignmentRepository.findById(assignmentId);
		if (optA.isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Invalid assignment primary key. " + assignmentId);
		}
		Assignment a = optA.get();
		
		// check that instructor matches course
		checkInstructorCoursePerms(a.getCourse().getCourse_id(), email);
		
		if (assignmentDTO.assignmentName != null && !assignmentDTO.assignmentName.trim().isEmpty()) {
			a.setName(assignmentDTO.assignmentName);
		}
		
		assignmentRepository.save(a);
		
		AssignmentListDTO.AssignmentDTO assignmentDTORes = new AssignmentListDTO.AssignmentDTO();
		assignmentDTORes.assignmentId = a.getId();
		assignmentDTORes.assignmentName = a.getName();
		assignmentDTORes.dueDate = a.getDueDate().toString();
		assignmentDTORes.courseTitle = a.getCourse().getTitle();
		assignmentDTORes.courseId = a.getCourse().getCourse_id();
		
		return assignmentDTORes;
	}
	
	// @author Ericka Koyama
	@DeleteMapping("/assignment/{id}")
	@Transactional
	public void deleteAssignment (@PathVariable("id") int assignmentId) {
		String email = "dwisneski@csumb.edu";  // user name (should be instructor's email)
		// Create assignment entity
		Optional<Assignment> optA = assignmentRepository.findById(assignmentId);
		if (optA.isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Invalid assignment primary key. "+assignmentId);
		}
		Assignment a = optA.get();
		
		// check that instructor matches course
		checkInstructorCoursePerms(a.getCourse().getCourse_id(), email);
		
		// can only delete if there are no grades for the assignment
		List<AssignmentGrade> ags = assignmentGradeRepository.findAllByAssignmentId(assignmentId);
		
		if (!ags.isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Cannot delete an assignment with grades. "+assignmentId);
		}
		
		assignmentRepository.delete(a);
	}
	
	private Assignment checkAssignment(int assignmentId, String email) {
		// get assignment 
		Optional<Assignment> optA = assignmentRepository.findById(assignmentId);
		if (optA.isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Assignment not found. "+assignmentId );
		}
		Assignment assignment = optA.get();
		
		// check that user is the course instructor
		if (!assignment.getCourse().getInstructor().equals(email)) {
			throw new ResponseStatusException( HttpStatus.UNAUTHORIZED, "Not Authorized. " );
		}
		
		return assignment;
	}
	
	private Course checkInstructorCoursePerms(int courseId, String email) {
		// get course
		Course course = courseRepository.findByCourse_id(courseId);
		if (course == null) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Course not found. "+courseId );
		}
		// check that user is the course instructor
		if (!course.getInstructor().equals(email)) {
			throw new ResponseStatusException( HttpStatus.UNAUTHORIZED, "Not Authorized. " );
		}
		
		return course;
	}
	
	private void checkNewAssignmentFields(AssignmentListDTO.AssignmentDTO assignment) {
		if (assignment == null) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "No assignment data passed.");
		}
		// check that the assignment has a due date
		if (assignment.dueDate == null && !assignment.dueDate.trim().isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Missing assignment due date field");
		}
		// check that the assignment has a name
		if (assignment.assignmentName == null && !assignment.assignmentName.trim().isEmpty()) {
			throw new ResponseStatusException( HttpStatus.BAD_REQUEST, "Missing assignment name field.");
		}
	}

}
